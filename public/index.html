<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Our Premium Canvas ğŸ¨</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background-color: #ffffff; font-family: system-ui, sans-serif; transition: background-color 0.3s ease; }
        canvas { display: block; background-color: transparent; }
        
        .toolbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.85); backdrop-filter: blur(10px);
            padding: 12px 20px; border-radius: 40px; box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            display: flex; gap: 15px; align-items: center; z-index: 10; max-width: 90%; overflow-x: auto; white-space: nowrap;
        }
        .toolbar::-webkit-scrollbar { display: none; }
        .tool-group { display: flex; flex-direction: column; align-items: center; font-size: 10px; font-weight: bold; color: #555; gap: 4px; }
        
        button { padding: 10px; border: none; border-radius: 50%; font-size: 18px; width: 45px; height: 45px; cursor: pointer; background-color: #f0f0f0; box-shadow: inset 0 2px 4px rgba(255,255,255,0.8), 0 2px 4px rgba(0,0,0,0.1); }
        button:active { transform: scale(0.9); }
        .active-tool { background-color: #333 !important; color: white !important; box-shadow: none; }
        
        #clearBtn { background-color: #ffeaea; } #undoBtn { background-color: #fff0d4; }
        input[type="color"] { -webkit-appearance: none; border: 2px solid #ddd; width: 40px; height: 40px; padding: 0; border-radius: 50%; overflow: hidden; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; } input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }
        input[type="range"] { width: 80px; accent-color: #333; }
        select { font-size: 20px; border: none; background: transparent; outline: none; }
        #imageLoader { display: none; }

        /* NEW: Styling for the text input box inside the toolbar */
        #textInput {
            border: 2px solid #ddd;
            border-radius: 15px;
            padding: 5px 10px;
            width: 100px;
            font-size: 14px;
            outline: none;
        }

        #partnerPointer {
            position: absolute; font-size: 24px; pointer-events: none; transition: opacity 0.3s; opacity: 0; z-index: 5; transform: translate(-50%, -100%);
        }
    </style>
</head>
<body>

    <div id="partnerPointer">ğŸ‘†</div>

    <div class="toolbar">
        <div class="tool-group"><span>Pen</span><input type="color" id="colorPicker" value="#000000"></div>
        <div class="tool-group"><span>Size</span><input type="range" id="brushSize" min="1" max="50" value="5"></div>
        <div class="tool-group"><span>Highlight</span><button id="highlightBtn">ğŸ–ï¸</button></div>
        <div class="tool-group"><span>Undo</span><button id="undoBtn">â†©ï¸</button></div>

        <div class="tool-group"><span>Stamp</span><button id="stampBtn">ğŸ’–</button></div>
        <div class="tool-group"><span style="visibility:hidden">Pick</span>
            <select id="emojiPicker"><option value="â¤ï¸">â¤ï¸</option><option value="â­">â­</option><option value="ğŸ˜‚">ğŸ˜‚</option><option value="ğŸ”¥">ğŸ”¥</option></select>
        </div>
        
        <div class="tool-group"><span>Text</span><button id="textBtn">ğŸ”¤</button></div>
        <div class="tool-group"><span>Type Here</span><input type="text" id="textInput" placeholder="Hello!"></div>
        
        <div class="tool-group"><span>Photo</span><button id="imageBtn" onclick="document.getElementById('imageLoader').click();">ğŸ“·</button><input type="file" id="imageLoader" accept="image/*"></div>
        <div class="tool-group"><span>Eraser</span><button id="eraserBtn">ğŸ§½</button></div>
        <div class="tool-group"><span>Clear</span><button id="clearBtn">ğŸ—‘ï¸</button></div>
    </div>

    <canvas id="drawingBoard"></canvas>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const canvas = document.getElementById('drawingBoard');
        const ctx = canvas.getContext('2d');
        const partnerPointer = document.getElementById('partnerPointer');
        
        // UI
        const colorPicker = document.getElementById('colorPicker');
        const brushSize = document.getElementById('brushSize');
        const eraserBtn = document.getElementById('eraserBtn');
        const clearBtn = document.getElementById('clearBtn');
        const stampBtn = document.getElementById('stampBtn');
        const textBtn = document.getElementById('textBtn');
        const highlightBtn = document.getElementById('highlightBtn');
        const undoBtn = document.getElementById('undoBtn');
        const textInput = document.getElementById('textInput');

        let history = [];
        const MAX_HISTORY = 10;

        function saveState() {
            history.push(canvas.toDataURL());
            if (history.length > MAX_HISTORY) history.shift(); 
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            saveState(); 
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        let isDrawing = false, currentX = 0, currentY = 0;
        let isEraser = false, isStamping = false, isTextMode = false, isHighlight = false;

        function resetTools() {
            isEraser = isStamping = isTextMode = isHighlight = false;
            eraserBtn.classList.remove('active-tool'); stampBtn.classList.remove('active-tool');
            textBtn.classList.remove('active-tool'); highlightBtn.classList.remove('active-tool');
        }

        eraserBtn.addEventListener('click', () => { resetTools(); isEraser = true; eraserBtn.classList.add('active-tool'); });
        stampBtn.addEventListener('click', () => { resetTools(); isStamping = true; stampBtn.classList.add('active-tool'); });
        textBtn.addEventListener('click', () => { resetTools(); isTextMode = true; textBtn.classList.add('active-tool'); });
        highlightBtn.addEventListener('click', () => { resetTools(); isHighlight = true; highlightBtn.classList.add('active-tool'); });
        colorPicker.addEventListener('change', resetTools);

        function getTouchPos(e) {
            const rect = canvas.getBoundingClientRect();
            return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
        }

        let pointerTimeout;
        
        // NEW: Drag and Drop variables
        let isDraggingItem = false;
        let dragType = ''; 
        let dragData = {};
        let savedImageData = null;
        let lastX = 0, lastY = 0;

        canvas.addEventListener('touchstart', (e) => {
            if(e.target === canvas) e.preventDefault(); 
            const pos = getTouchPos(e);
            lastX = pos.x; lastY = pos.y;
            
            socket.emit('pointer', {x: pos.x, y: pos.y});

            // Handle Drag-to-Place for Text and Stamps
            if (isTextMode || isStamping) {
                isDraggingItem = true;
                dragType = isTextMode ? 'text' : 'stamp';
                
                // Take a quick photo of the canvas before we draw the text
                savedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                if (isTextMode) {
                    const textVal = textInput.value;
                    if (!textVal) { alert("Please type something in the text box first!"); isDraggingItem = false; return; }
                    dragData = { text: textVal, size: brushSize.value * 4, color: colorPicker.value };
                    drawText(dragData.text, pos.x, pos.y, dragData.color, dragData.size, false);
                } else {
                    dragData = { emoji: document.getElementById('emojiPicker').value, size: brushSize.value * 4 };
                    drawStamp(pos.x, pos.y, dragData.emoji, dragData.size, false);
                }
                return; 
            }

            isDrawing = true; currentX = pos.x; currentY = pos.y;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if(e.target === canvas) e.preventDefault();
            const pos = getTouchPos(e);
            lastX = pos.x; lastY = pos.y;
            
            socket.emit('pointer', {x: pos.x, y: pos.y});

            // NEW: If dragging text/stamp, move it with the finger!
            if (isDraggingItem) {
                // Wipe the screen back to what it was right before we touched it
                ctx.putImageData(savedImageData, 0, 0);
                
                // Draw the text/stamp at the new finger position
                if (dragType === 'text') {
                    drawText(dragData.text, pos.x, pos.y, dragData.color, dragData.size, false);
                } else {
                    drawStamp(pos.x, pos.y, dragData.emoji, dragData.size, false);
                }
                return;
            }

            if (!isDrawing) return;

            ctx.globalCompositeOperation = isEraser ? 'destination-out' : 'source-over';
            ctx.globalAlpha = isHighlight ? 0.3 : 1.0; 

            drawLine(currentX, currentY, pos.x, pos.y, colorPicker.value, brushSize.value, true, isEraser, isHighlight);
            currentX = pos.x; currentY = pos.y;
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            // NEW: Lock the text/stamp in place and tell the server!
            if (isDraggingItem) {
                isDraggingItem = false;
                if (dragType === 'text') {
                    socket.emit('text', { text: dragData.text, x: lastX, y: lastY, color: dragData.color, size: dragData.size });
                } else {
                    socket.emit('stamp', { emoji: dragData.emoji, x: lastX, y: lastY, size: dragData.size });
                }
                saveState();
                return;
            }

            if (isDrawing) saveState(); 
            isDrawing = false;
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1.0;
        });

        // --- Core Drawing Functions ---
        function drawLine(x0, y0, x1, y1, color, size, emit, erasing, highlight) {
            ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(x1, y1);
            ctx.strokeStyle = color; ctx.lineWidth = size; ctx.lineCap = 'round'; ctx.stroke(); ctx.closePath();
            if (!emit) return;
            socket.emit('drawing', { x0, y0, x1, y1, color, size, erasing, highlight });
        }

        socket.on('drawing', (data) => {
            ctx.globalCompositeOperation = data.erasing ? 'destination-out' : 'source-over';
            ctx.globalAlpha = data.highlight ? 0.3 : 1.0;
            drawLine(data.x0, data.y0, data.x1, data.y1, data.color, data.size, false, data.erasing, data.highlight);
            ctx.globalCompositeOperation = 'source-over'; ctx.globalAlpha = 1.0;
        });

        function drawStamp(x, y, emoji, size, emit) {
            ctx.font = `${size}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = "black"; ctx.fillText(emoji, x, y);
            if (emit) socket.emit('stamp', { x, y, emoji, size });
        }
        socket.on('stamp', (data) => drawStamp(data.x, data.y, data.emoji, data.size, false));

        function drawText(text, x, y, color, size, emit) {
            ctx.font = `bold ${size}px system-ui`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = color; ctx.fillText(text, x, y);
            if (emit) socket.emit('text', { text, x, y, color, size });
        }
        socket.on('text', (data) => drawText(data.text, data.x, data.y, data.color, data.size, false));

        socket.on('pointer', (data) => {
            partnerPointer.style.left = data.x + 'px';
            partnerPointer.style.top = data.y + 'px';
            partnerPointer.style.opacity = 1; 
            clearTimeout(pointerTimeout);
            pointerTimeout = setTimeout(() => { partnerPointer.style.opacity = 0; }, 1000); 
        });

        function performUndo(emit) {
            if (history.length > 1) {
                history.pop(); 
                const previousState = history[history.length - 1]; 
                const img = new Image();
                img.src = previousState;
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                }
                if (emit) socket.emit('undo');
            }
        }
        undoBtn.addEventListener('click', () => performUndo(true));
        socket.on('undo', () => performUndo(false));

        function clearCanvas() { ctx.clearRect(0, 0, canvas.width, canvas.height); saveState(); }
        clearBtn.addEventListener('click', () => { clearCanvas(); socket.emit('clear'); });
        socket.on('clear', () => { clearCanvas(); });

        // Image loading logic
        imageLoader.addEventListener('change', function(e) {
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    const maxDim = window.innerWidth * 0.8; 
                    let scale = 1;
                    if (img.width > maxDim || img.height > maxDim) scale = Math.min(maxDim / img.width, maxDim / img.height);
                    const w = img.width * scale, h = img.height * scale;
                    const startX = (canvas.width - w) / 2, startY = (canvas.height - h) / 2;
                    ctx.drawImage(img, startX, startY, w, h);
                    saveState();

                    const tempC = document.createElement('canvas');
                    tempC.width = w; tempC.height = h;
                    tempC.getContext('2d').drawImage(img, 0, 0, w, h);
                    socket.emit('image', { imgData: tempC.toDataURL('image/jpeg', 0.6), x: startX, y: startY, w: w, h: h });
                }
                img.src = event.target.result;
            }
            if(e.target.files[0]) reader.readAsDataURL(e.target.files[0]);
        }, false);
        socket.on('image', (data) => {
            const img = new Image();
            img.onload = () => { ctx.drawImage(img, data.x, data.y, data.w, data.h); saveState(); }
            img.src = data.imgData;
        });
    </script>
</body>
</html>
